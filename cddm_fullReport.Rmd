---
title: "A comparison between different simulation algorithms for the CDDM in R"
author: "Adriana F. Chávez De la Peña"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
    fig_width: 12 
    fig_height: 8 
---

```{r setup, include=FALSE}
# Start Rmarkdown set up
knitr::opts_chunk$set(echo = TRUE)
library(rmdformats)
# Declare higher variables
superCalled <- TRUE # When calling external scripts, don't load nested scripts.
test <- FALSE       # When calling external scripts, don't run tests
forceRun <- FALSE   # Whether we re-run all chunks, ignoring past saved results
# Call scripts containing auxiliary custom functions
source("./code/cddm/dCDDM.R") # CDDM likelihood function - Needed for ALL algorithms
source("./code/cddm/sim_randomWalk.R") # Needed for Fig.1 and Algorithm 1
source("./code/cddm/sim_MCMC.R") # Needed for Algorithm 2
source("./code/cddm/plottingFunctions.R") # Needed to plot choices on a circle
source("./code/cddm/pCDDM.R") # Needed for approximating the CDF under the CDDM
# Short custom functions for plotting
rgb.RW <- c(0.4,.9,.3)
rgb.MCMC <- c(0.15,.29,.80)
col.RW <- function(opacity){rgb(rgb.RW[1],rgb.RW[2],rgb.RW[3],opacity)}
col.MCMC <- function(opacity){rgb(rgb.MCMC[1],rgb.MCMC[2],rgb.MCMC[3],opacity)}
```

# The Circular Drift Diffusion Model

The circular drift-diffusion model (CDDM) is a stochastic sequential sampling model that describes choices and response times observed in tasks with a circular decision space (i.e., a bounded continuum; Smith, 2016). 

Like many other accumulator models, the CDDM assumes that participants accumulate information in favor of a given response option over time, until a response criteria is met. This information accumulation process is characterized by the model as a random walk that starts at the origin of the circle representing the decision space, and moves towards its circumference. The response observed corresponds to the point at which the random walk intersects the circumference, and its thus expressed in radians.

The CDDM considers four parameters, most of which are illustrated in Fig 1, with the one exception of the nondecision time parameter $\tau$. The remaining parameters are the boundary radius parameter ($\eta$) that serves as a response criterion, and a doublet of parameters describing the overall speed and direction of the information accumulation process. These last two parameters can be expressed in cartesian coordinates (i.e., the mean displacement observed on the X and Y coordinates per unit of time $\{\mu_x, \mu_y\}$) or polar coordinates (i.e., the average speed and expected direction $\{\delta,\theta\}$).

```{r, echo=FALSE, message=FALSE, fig.align='center', fig.cap="Fig 1. Graphical illustration of the CDDM"}
source("./code/cddm/illustrateModel_Fig1.R")
```

In this document, we present a compare different sampling algorithms to generate data under the CDDM. We will illustrate how these algorithms work and discuss the comparison method by generating `n = 5000` bivariate observatios using the same set of arbitrary parameter values:

```{r}
# Arbitrary set of parameter values
par <- list("drift" = 1, 
            "theta" = pi,
            "tzero" = 0.1,
            "boundary" = 7)
n <- 5000 # No. samples
```

# Algorithm 1: Random walk emulator

Each pair of observations is obtained by emulating the random walk process described by the CDDM and recording 1) the point at which the circumference is crossed and 2) the number of steps it took to get there.



```{r, eval=FALSE}
source("./code/cddm/sim_randomWalk.R")
X.RW <- sample.RW.cddm(n,par)
```

```{r,  echo=FALSE}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun|!file.exists("./tmp/X.RW.RData")){
      start_time <- Sys.time()
      X.RW <- sample.RW.cddm(n,par)
      end_time <- Sys.time()
      RW.time <- round(end_time-start_time,4)
      save(X.RW, file = "./tmp/X.RW.RData")
      save(RW.time, file = "./tmp/RW.time.RData")
}else{
     load("./tmp/X.RW.RData")    
     load("./tmp/RW.time.RData")
}
```

```{r, fig.height=5}
plot.CDDM(X.RW, par, choice.col.RGB = rgb.RW)
```


```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.RW$bivariate.data[,2], main = "Response Times", col = col.RW(0.7))
```

*The execution of this first algorithm took approximately `r RW.time` seconds.*

# Algorithm 2: Metropolis-Hasting MCMC

The following MCMC rejection-sampler algorithm (Metropolis-Hasting) uses the density function to generate random observations under the CDDM. Please read the comments I’ve left through the code to get a better idea on how this algorithm works. In order to work, this algorithm only needs a list par that specifies the values to use for each of the four parameters of the model (in either of its parameterizations, using polar or cartesian coordinates), and an arbitrary value max.RT that indicates the maximum possible R.T we’d expect to observe under a realistic scenario.

```{r}
max.RT <- max(X.RW$bivariate.data[,2])
```

```{r, eval=FALSE}
source("./code/cddm/sim_MCMC.R")
X.MCMC <- sample.MCMC.cddm(n,par,max.RT,plot=TRUE)
```

```{r,  echo=FALSE, fig.cap="Fig.2 Visual representation of the MCMC-MH rejection algorithm. The blue lines represent the joint density function of response times and choices prescribed by the CDDM. The dots represent the pairs of candidate value generated from the bivariate space of possible RTs and choices, plotted at the height of the random uniform(0, maxDensity) value used as rejection criterion. If the rejection criterion was lower than the density function (i.e., dot falls below density curve), the sample is accepted; if the rejection value surpasses the density (i.e., dot is drawn above), the candidate is rejected. The process of generating, testing and keeping candidates is repeated until the desired sample size is achieved."}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun|!file.exists("./tmp/X.MCMC.RData")){
      start_time <- Sys.time()
      X.MCMC <- sample.MCMC.cddm(n,par,max.RT,plot=TRUE)
      end_time <- Sys.time()
      MC.time <- round(end_time-start_time, 4)
      save(X.MCMC, file = "./tmp/X.MCMC.RData")
      save(MC.time, file = "./tmp/MC.time.RData")
}else{
     # Load already existing output
     load("./tmp/X.MCMC.RData")
     load("./tmp/MC.time.RData")
     # Run the sampling algorithm to show the illlustrative plot
     z <- sample.MCMC.cddm(n,par,max.RT,plot=TRUE)
}
```

*The execution of this second algorithm took approximately `r MC.time` seconds.*

```{r, fig.height=5}
plot.CDDM(X.MCMC, par, choice.col.RGB = rgb.MCMC)
```

```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.MCMC[,2], main = "Response Times", col=col.MCMC(0.7))
```

# Accuracy testing

### Step 1: Obtain empirical CDF (eCDF)

```{r}
# Load file containing custom eCDF function
source("./code/general_functions/eCDF.R")

MCMC.eCDF <- myECDF(X.MCMC)
RW.eCDF <- myECDF(X.RW$bivariate.data)

# Plot the eCDFs obtained so far
par(pty="s")          
par(mfrow=c(1,2),mar = c(0, 0, 0, 0)) 
myECDF.Plot(X.MCMC, color="goldenrod4")
myECDF.Plot(X.RW$bivariate.data, color="cyan4")
```

## Step 2: Approximate the theoretical CDF  (tCDF)

```{r, echo=FALSE}
# The two r-chunks below are actually just for display. This is where the CDFs are actually
# approximated from previously-saved output files, as indicated in the opening chunk.
if(forceRun|!file.exists("./tmp/MCMC.tCDF.RData")){
      start_time <- Sys.time()
      MCMC.tCDF <- pCDDM(X.MCMC, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      MC_tCDF.time <- round(end_time-start_time,4)
      save(MCMC.tCDF, file = "./tmp/MCMC.tCDF.RData")
      save(MC_tCDF.time, file = "./tmp/MC_tCDF.time.RData")
      start_time <- Sys.time()
      RW.tCDF <- pCDDM(X.RW$bivariate.data, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      RW_tCDF.time <- round(end_time-start_time,4)
      save(RW.tCDF, file = "./tmp/RW.tCDF.RData")
      save(RW_tCDF.time, file = "./tmp/RW_tCDF.time.RData")
}else{
     # Load already existing output
      load("./tmp/MCMC.tCDF.RData")
      load("./tmp/MC_tCDF.time.RData")
      load("./tmp/RW.tCDF.RData")
      load("./tmp/RW_tCDF.time.RData")
}
```

```{r, eval=FALSE}
source("./code/cddm/pCDDM.R")

# Approximate the theoretical CDF for the MCMC data
start_time <- Sys.time()
MCMC.tCDF <- pCDDM(X.MCMC, par$drift, par$theta, par$tzero, par$boundary)
end_time <- Sys.time()
MC_tCDF.time <- end_time-start_time
MC_tCDF.time <- round(MC_tCDF.time,4)
```

*Obtaining the approximate CDF for the MCMC data with a trapezoid algorithm took `r MC_tCDF.time` **minutes**.*

```{r, eval=FALSE}
# Approximate the theoretical CDF for the Random Walk data
start_time <- Sys.time()
RW.tCDF <- pCDDM(X.RW$bivariate.data, par$drift, par$theta, par$tzero, par$boundary)
end_time <- Sys.time()
RW_tCDF.time <- end_time-start_time
RW_tCDF.time <- round(RW_tCDF.time,4)
```

*Obtaining the approximate CDF for the Random-Walk data with a trapezoid algorithm took `r RW_tCDF.time` **minutes**.*

## Step 3: Compare eCDFs vs approximate tCDF

```{r}
par(pty="s")          
par(mfrow=c(1,2),mar = c(0, 0, 0, 0)) 
scatterplot3d(X.MCMC[,1],X.MCMC[,2],MCMC.tCDF, pch=16,
              cex.symbols = 0.5, color = "goldenrod4",
              xlab = "Choices", ylab = "RT", zlab = "CDF (approximate)")
scatterplot3d(X.RW$bivariate.data[,1],X.RW$bivariate.data[,2],RW.tCDF, pch=16,
              cex.symbols = 0.5, color = "cyan4", xlab = "Choices", 
              ylab = "RT", zlab = "CDF (approximate)")
```

```{r}
# We build a simple function to compare these CDFs
getDifferences <- function(eCDF,tCDF){
  difference <- tCDF - eCDF
  difference.sum <- sum(difference)
  Kldivergence <- max(abs(difference))
  sq.difference <- sum((difference)^2)
  
  output <- round(cbind(difference.sum,Kldivergence,sq.difference),4)
  colnames(output) <- c("sumDiff","Kldivergence","SSDiff") 
  return(output)
}
```


```{r}
getDifferences(MCMC.eCDF,MCMC.tCDF)
getDifferences(RW.eCDF,RW.tCDF)
```

# Comparing computation times

```{r}
N <- 1:5
M <- 20

times.RW   <- matrix(NA, nrow=M, ncol=max(N))
times.MCMC <- matrix(NA, nrow=M, ncol=max(N))
for(m in 1:M){
    for(n in N){
      start_time <- Sys.time()
      sample.RW.cddm(n,par)
      end_time <- Sys.time()
      times.RW[m,n] <- round(end_time-start_time,4)
      
      start_time <- Sys.time()
      sample.MCMC.cddm(n,par,max.RT,plot=FALSE)
      end_time <- Sys.time()
      times.MCMC[m,n] <- round(end_time-start_time, 4)
    }
}
```

```{r, echo=FALSE}
x <- rep(N, each=M)
x.RW <- (rep(N, each=M)+0.15)+(rnorm(max(N)*M,0,0.02))
x.MCMC <- (rep(N, each=M)-0.15)+(rnorm(max(N)*M,0,0.015))
t.RW <- c(times.RW)
t.MCMC <- c(times.MCMC)

max.CompTime <- max(times.RW)

plot(x.RW,t.RW, ylim=c(0,max.CompTime), xlim=c(0,max(N)+1), pch=16, cex=0.8,
     col = rgb(0.4,0.9,0.3,0.5), ann=F, axes=F)
points(x.MCMC,t.MCMC, pch=16, cex=0.8, col=rgb(0.15,.29,.80,0.5))
axis(1, N, paste("n = ", N))
mtext("Sample size", 1, line=2.5, f=2)
axis(2, seq(0,max.CompTime,0.01), seq(0,max.CompTime,0.01), las=2, line=-1.1)
mtext("Computation Time (in secs)", 2, line=2.5, f=2)
abline(lm(t.RW ~x), col = rgb(0.4,0.9,0.3,0.8), lwd=2)
abline(lm(t.MCMC ~x), col=rgb(0.15,.29,.80,0.8), lwd=2)
legend(0.5,max.CompTime, col= c(rgb(0.4,0.9,0.3,0.8),rgb(0.15,.29,.80,0.8)), c("RW", "MCMC"), lwd=2, bty = "n")
```

```{r}
lm(t.RW ~x)
```

```{r}
lm(t.MCMC ~x)
```



# References

- Smith, P. L. (2016). Diffusion theory of decision making in continuous report. Psychological Review, 123(4), 425.