---
title: "Simulation algorithms for the CDDM in R"
author: "Adriana F. Chávez De la Peña"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
    fig_width: 12 
    fig_height: 8 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(rmdformats)

superCalled <- TRUE

source("./code/cddm/sim_randomWalk.R")
source("./code/cddm/dCDDM.R")

test <- FALSE
```

# The Circular Drift Diffusion Model

The circular drift-diffusion model (CDDM) is a stochastic sequential sampling model that describes choices and response times observed in tasks with a circular decision space (i.e., a bounded continuum; Smith, 2016). 

Like many other accumulator models, the assumes that information gets accumulated over time, moving from a starting point located at the origin of a circle representing the decision space, towards its circumference. Responses made by participants are expressed in radians.

The CDDM considers four parameters. 

1. The nondecision time $\tau$

2. The boundary radius (i.e., the response criterion) $\eta$. 

3. A douplet of parameters related to the information provided by the stimulus: $\mu_x$ and $\mu_y$ OR $\theta$ and $\delta$.

<!-- 3. A douplet of parameters related to the information provided by the stimulus and its effect on the decision process. These last two parameters describe the overall direction and speed of the random walk either in terms of cartesian or polar coordinates. If expressed as a cartesian coordinates, parameters μx and μy are used to denote the average step size that the random walk takes per unit of time along the X and Y axes, respectively. Whereas, if expressed as polar coordinates, parameters θ and δ are used to describe the angle that corresponds to the -->
<!-- correct answer (i.e., drift angle) and the average speed at which the random walk approaches the -->
<!-- circumference (i.e., drift magnitude), respectively (Smith, 2016; Kvam, 2019). -->

Below we have a graphical representation of the CDDM (non-decision time is not included)

```{r, echo=FALSE, message=FALSE, fig.align='center'}
source("./code/cddm/illustrateModel_Fig1.R")
```

# Algorithm 1: Random walk emulator

```{r}
# 2: Define some parameter values and sample size ~ #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Some parameter values
par <- list("drift" = 1, 
            "theta" = pi,
            "tzero" = 0.1,
            "boundary" = 7)
n <- 5000 # No. samples
```

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r, eval=FALSE}
source("./code/cddm/sim_randomWalk.R")
X.RW <- sample.RW.cddm(n,par)
```

```{r, echo=FALSE}
end_time <- Sys.time()
RW.time <- end_time-start_time
RW.time <- round(RW.time,4)
```

```{r, eval=TRUE, echo=FALSE}
source("./code/cddm/sim_randomWalk.R")
#save(X.RW, file = "./tmp/X.RW.RData")
load("./tmp/X.RW.RData")
#save(RW.time, file = "./tmp/RW.time.RData")
load("./tmp/RW.time.RData")
```

*The execution of this first algorithm took approximately `r RW.time` seconds.*

# Algorithm 2: Metropolis-Hasting MCMC

```{r}
max.RT <- max(X.RW$bivariate.data[,2])
```

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r, eval=FALSE}
source("./code/cddm/sim_MCMC.R")
X.MCMC <- sample.MCMC.cddm(n,par,max.RT,plot=TRUE)
```

```{r, echo=FALSE}
end_time <- Sys.time()
MC.time <- end_time-start_time
MC.time <- round(MC.time,4)
```

```{r, eval=TRUE, echo=FALSE}
source("./code/cddm/sim_MCMC.R")
#save(X.MCMC, file = "./tmp/X.MCMC.RData")
load("./tmp/X.MCMC.RData")
#save(MC.time, file = "./tmp/MC.time.RData")
load("./tmp/MC.time.RData")
```

*The execution of this second algorithm took approximately `r MC.time` seconds.*

# Comparison (Single run)

## Visualize the output

### Choices

```{r}
par(pty="m")          
par(mfrow=c(2,1),mar = c(3, 3, 3, 0)) 
# Choices
hist(X.RW$bivariate.data[,1], main="Choices on Random Walk",
     xlim=c(0,2*pi), col="goldenrod4")
hist(X.MCMC[,1], main= "Choices on MCMC", xlim=c(0,2*pi), col="cyan4")
```

```{r}
source("./code/cddm/plottingFunctions.R")

par(pty="m")          
par(mfrow=c(1,2),mar = c(3, 3, 3, 0)) 
# Decisions on a circle
plot.CDDM(X.RW, par, choice.col.RGB = c(0.4,.9,.3))
plot.CDDM(X.MCMC, par, choice.col.RGB = c(0.15,.29,.80))
```

### Response Times

```{r}
par(pty="m")          
par(mfrow=c(2,1),mar = c(3, 3, 3, 0)) 
# Response Times
hist(X.RW$bivariate.data[,2], main = "RT on Random Walk", col="goldenrod3")
hist(X.MCMC[,2], main = "RT on MCMC", col="cyan4")
```

## Accuracy test

### Step 1: Obtain empirical CDF (eCDF)

```{r}
# Load file containing custom eCDF function
source("./code/general_functions/eCDF.R")

MCMC.eCDF <- myECDF(X.MCMC)
RW.eCDF <- myECDF(X.RW$bivariate.data)

# Plot the eCDFs obtained so far
par(pty="s")          
par(mfrow=c(1,2),mar = c(0, 0, 0, 0)) 
myECDF.Plot(X.MCMC, color="goldenrod4")
myECDF.Plot(X.RW$bivariate.data, color="cyan4")
```

## Step 2: Approximate the theoretical CDF  (tCDF)

```{r, eval=TRUE, echo=FALSE}
source("./code/cddm/pCDDM.R")
#save(MCMC.tCDF, file = "./tmp/MCMC.tCDF.RData")
load("./tmp/MCMC.tCDF.RData")
#save(MC_tCDF.time, file = "./tmp/MC_tCDF.time.RData")
load("./tmp/MC_tCDF.time.RData")
#save(RW.tCDF, file = "./tmp/RW.tCDF.RData")
load("./tmp/RW.tCDF.RData")
#save(RW_tCDF.time, file = "./tmp/RW_tCDF.time.RData")
load("./tmp/RW_tCDF.time.RData")
```


```{r, eval=FALSE}
source("./code/cddm/pCDDM.R")

# Approximate the theoretical CDF for the MCMC data
start_time <- Sys.time()
MCMC.tCDF <- pCDDM(X.MCMC, par$drift, par$theta, par$tzero, par$boundary)
end_time <- Sys.time()
MC_tCDF.time <- end_time-start_time
MC_tCDF.time <- round(MC_tCDF.time,4)
```

*Obtaining the approximate CDF for the MCMC data with a trapezoid algorithm took `r MC_tCDF.time` **minutes**.*

```{r, eval=FALSE}
# Approximate the theoretical CDF for the Random Walk data
start_time <- Sys.time()
RW.tCDF <- pCDDM(X.RW$bivariate.data, par$drift, par$theta, par$tzero, par$boundary)
end_time <- Sys.time()
RW_tCDF.time <- end_time-start_time
RW_tCDF.time <- round(RW_tCDF.time,4)
```

*Obtaining the approximate CDF for the Random-Walk data with a trapezoid algorithm took `r RW_tCDF.time` **minutes**.*

## Step 3: Compare eCDFs vs approximate tCDF

```{r}
# We build a simple function to compare these CDFs

getDifferences <- function(eCDF,tCDF){
  difference <- tCDF - eCDF
  difference.sum <- sum(difference)
  Kldivergence <- max(abs(difference))
  sq.difference <- sum((difference)^2)
  
  output <- round(cbind(difference.sum,Kldivergence,sq.difference),4)
  colnames(output) <- c("sumDiff","Kldivergence","SSDiff") 
  return(output)
}
```


```{r}
getDifferences(MCMC.eCDF,MCMC.tCDF)
getDifferences(RW.eCDF,RW.tCDF)
```

```{r, eval=FALSE, echo=FALSE}
lab.x <- colnames(data)[1]
      lab.y <- colnames(data)[2]
      if(is.null(lab.x)){ lab.x <-"Dimension 1" }
      if(is.null(lab.y)){ lab.y <-"Dimension 2" }
      scatterplot3d(data[,1],data[,2],eCDF, pch=16,
                    cex.symbols = 0.5, color = eCDF.color,
                    xlab = lab.x, ylab = lab.y, zlab = "eCDF")
    x.tCDF <- pnorm(x,true.mean,true.sd)
    getDifferences(x.eCDF,x.tCDF)
    # Data comes from bivariate normal
    true.means <- c(10,10)
    true.sds <- diag(length(true.means))
    y <- mvtnorm::rmvnorm(1000,true.means,true.sds)
    y.eCDF <- myECDF(y)
    myECDF.Plot(y)
    y.tCDF <- pnorm(y,true.mean,true.sd)

```
    