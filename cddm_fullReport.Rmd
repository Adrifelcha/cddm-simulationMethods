---
title: "A comparison between sampling algorithms for the CDDM in R"
author: "Adriana F. Chávez De la Peña"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
    fig_width: 12 
    fig_height: 8 
---

```{r setup, include=FALSE}
# Start Rmarkdown set up
knitr::opts_chunk$set(echo = TRUE)
library(rmdformats)
# Declare higher variables
superCalled <- TRUE # When calling external scripts, don't load nested scripts.
test <- FALSE       # When calling external scripts, don't run tests
# Whether we re-run all chunks, ignoring past saved results
forceRun_RW <- FALSE    # Re-run Random-walk algorithm
forceRun_Rej <- FALSE    #
forceRun_Met <- TRUE    # 
forceRun_inv <- TRUE   #
forceRun <- forceRun_RW | forceRun_Rej | forceRun_Met | forceRun_inv
# Call scripts containing auxiliary custom functions
source("./code/cddm/dCDDM.R") # CDDM likelihood function - Needed for ALL algorithms
source("./code/cddm/pCDDM.R") # Needed for approximating the CDF under the CDDM
source("./code/general_functions/eCDF.R") # Needed for computing empirical CDF
source("./code/cddm/sim_randomWalk.R") # Needed for Algorithm 1 and Fig.1
source("./code/cddm/sim_Reject.R")     # Needed for Algorithm 2
source("./code/cddm/sim_Metropolis.R") # Needed for Algorithm 3
source("./code/cddm/sim_invCDF.R")     # Needed for Algorithm 4
source("./code/cddm/plottingFunctions.R") # Needed to make custom CDDM plots
# Short custom functions for plotting
rgb.RW <- c(255/255,128/255,0)
rgb.Reject <- c(0.4,.9,.3)
rgb.Metro  <- c(127/255, 0, 1)
rgb.invCDF <- c(0, 128/255, 1)
col.RW <- function(opacity){rgb(rgb.RW[1],rgb.RW[2],rgb.RW[3],opacity)}
col.Reject <- function(opacity){rgb(rgb.Reject[1],rgb.Reject[2],rgb.Reject[3],opacity)}
col.invCDF <- function(opacity){rgb(rgb.invCDF[1],rgb.invCDF[2],rgb.invCDF[3],opacity)}
col.Metro <- function(opacity){rgb(rgb.Metro[1],rgb.Metro[2],rgb.Metro[3],opacity)}
```

<!-- # Introduction -->

<!-- The present document is included as support material for the project presented in: -->

<!-- > Chávez De la Peña, A. F. & Vandekerckhove, J. (n.a.). Simulating circular decisions using the circular drift-diffusion model: A comparison across different simulation methods. *work in progress*. -->

<!-- The main goal of the project was to develop different sampling algorithms that could be used to generate data under the CDDM, and compare their performance in terms of computation time and accuracy.  -->

<!-- This document is a short report intended to provide an executive  -->



# The Circular Drift Diffusion Model

The circular drift-diffusion model (CDDM) is a stochastic sequential sampling model that describes choices and response times observed in tasks with a circular decision space (Smith, 2016). Like many other accumulator models, the CDDM assumes that participants accumulate information in favor of a given response option over time, until a response criteria is met. This is characterized as a random walk that starts at the origin of a circle representing the decision space, and that moves towards its circumference. Once the circumference is reached, the radian corresponding to the point of intersection and the amount of steps it took to get there are indicative of the choice and response times observed.

The CDDM considers four parameters, most of which are illustrated in Fig 1. The parameter not shown is the nondecision time parameter $\tau$. The remaining parameters are the boundary radius parameter ($\eta$) that serves as a response criterion, and a doublet of parameters describing the overall speed and direction of the information accumulation process. These last two parameters can be expressed in cartesian coordinates (i.e., the mean displacement observed on the X and Y coordinates per unit of time $\{\mu_x, \mu_y\}$) or polar coordinates (i.e., the average speed and expected direction $\{\delta,\theta\}$).

```{r, echo=FALSE, message=FALSE, fig.align='center', fig.cap="Fig 1. Graphical illustration of the CDDM"}
# Arbitrary set of parameter values
drift <- 3.7; theta <- 5.3; tzero <- 0.1; boundary <- 3
par <- list("drift" = drift, "theta" = theta,
            "tzero" = tzero, "boundary" = boundary)
n <- 1000 # No. samples

set.seed(777)
data_fig1 <- plot.CDDM_Fig1(n,par,return.RW = TRUE)
```

## dCDDM(*) - CDDM density function

```{r}
source("./code/cddm/dCDDM.R")

choice <- 5; rt <- 1
dCDDM(c(choice,rt),drift,theta,tzero,boundary)
```

## pCDDM(*) - CDDM cumulate density function

```{r}
source("./code/cddm/pCDDM.R")

x <- pCDDM(data_fig1, drift, theta, tzero, boundary, plot=TRUE)
```

## Illustrative parameter set

```{r set-up, echo=FALSE}
# Arbitrary set of parameter values
par <- list("drift" = 3.5, 
            "theta" = pi,
            "tzero" = 0.2,
            "boundary" = 2)
n <- 5000 # No. samples
```

In this document, we present a comparison between different sampling algorithms that generate data under the CDDM. We will describe how each of these algorithms work and highlight how different they are in terms of the computation time they require and their accuracy. For starters, we will generate `n = ` `r n` bivariate observations using the arbitrary set of parameter values shown below:

```{r set-up, eval=FALSE}
```


# Algorithm 1: Random walk emulator

Each pair of observations is obtained by emulating the random walk process described by the CDDM. We emulate the information accumulation process by iteratively sampling random movements on the X and Y direction using $\mu_x$ and $\mu_y$, until the 

```{r, eval=FALSE}
source("./code/cddm/sim_randomWalk.R")
X.RW <- sample.RW.cddm(n,par)
```

```{r,  echo=FALSE}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun_RW|!file.exists("./tmp/X.RW.RData")){
      start_time <- Sys.time()
      X.RW <- sample.RW.cddm(n,par)
      end_time <- Sys.time()
      RW.time <- round(end_time-start_time,4)
      save(X.RW, file = "./tmp/X.RW.RData")
      save(RW.time, file = "./tmp/RW.time.RData")
}else{
     load("./tmp/X.RW.RData")    
     load("./tmp/RW.time.RData")
}
```

```{r, fig.height=5}
plot.CDDM_choiceData(X.RW, par, choice.col.RGB = rgb.RW)
```


```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.RW$bivariate.data[,2], main = "Response Times", col = col.RW(0.7))
```

```{r, fig.height=5, echo=FALSE}
plot.CDDM_margECDF(X.RW$bivariate.data, color=col.RW(0.3))
```


**The execution of the Random Walk emulator algorithm took approximately `r RW.time` seconds.**

# Algorithm 2: Rejection sampling algorithm

```{r}
max.RT <- max(X.RW$bivariate.data[,2])
```

```{r, eval=FALSE}
source("./code/cddm/sim_Reject.R")
X.Reject <- sample.Reject.cddm(n,par,max.RT,plot=TRUE)
```

```{r,  echo=FALSE, fig.cap="Fig.2 Visual representation of the Reject sampling algorithm. The blue lines represent the joint density function of response times and choices prescribed by the CDDM. The dots represent the pairs of candidate value generated from the bivariate space of possible RTs and choices, plotted at the height of the random uniform(0, maxDensity) value used as rejection criterion. If the rejection criterion was lower than the density function (i.e., dot falls below density curve), the sample is accepted; if the rejection value surpasses the density (i.e., dot is drawn above), the candidate is rejected. The process of generating, testing and keeping candidates is repeated until the desired sample size is achieved."}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun_Rej|!file.exists("./tmp/X.Reject.RData")){
      start_time <- Sys.time()
      X.Reject <- sample.Reject.cddm(n,par,max.RT,plot=TRUE)
      end_time <- Sys.time()
      Reject.time <- round(end_time-start_time, 4)
      save(X.Reject, file = "./tmp/X.Reject.RData")
      save(Reject.time, file = "./tmp/Reject.time.RData")
}else{
     # Load already existing output
     load("./tmp/X.Reject.RData")
     load("./tmp/Reject.time.RData")
     # Run the sampling algorithm to show the illlustrative plot
     z <- sample.Reject.cddm(n,par,max.RT,plot=TRUE)
}
```

```{r, fig.height=5}
plot.CDDM_choiceData(X.Reject, par, choice.col.RGB = rgb.Reject)
```

```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.Reject[,2], main = "Response Times", col=col.Reject(0.7))
```

```{r, fig.height=5, echo=FALSE}
plot.CDDM_margECDF(X.Reject, color=col.Reject(0.3))
```

**The execution of the Rejection sampling algorithm took approximately `r Reject.time` seconds.**

# Algorithm 3: Metropolis algorithm

The following Metropolis algorithm uses the density function to generate random observations under the CDDM. Please read the comments I’ve left through the code to get a better idea on how this algorithm works. In order to work, this algorithm only needs a list par that specifies the values to use for each of the four parameters of the model (in either of its parameterizations, using polar or cartesian coordinates), and an arbitrary value max.RT that indicates the maximum possible R.T we’d expect to observe under a realistic scenario.

```{r, eval=FALSE}
source("./code/cddm/sim_Metropolis.R")
X.Metro <- sample.Metropolis.cddm(n,par,max.RT,plot=TRUE)
```

```{r,  echo=FALSE, fig.cap="Fig.2 Visual representation of the Metropolis sampling algorithm. The blue lines represent the joint density function of response times and choices prescribed by the CDDM. The dots represent the pairs of candidate value generated from the bivariate space of possible RTs and choices, plotted at the height of the random uniform(0, maxDensity) value used as rejection criterion. If the rejection criterion was lower than the density function (i.e., dot falls below density curve), the sample is accepted; if the rejection value surpasses the density (i.e., dot is drawn above), the candidate is rejected. The process of generating, testing and keeping candidates is repeated until the desired sample size is achieved."}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun_Met|!file.exists("./tmp/X.Metro.RData")){
      start_time <- Sys.time()
      X.Metro <- sample.Metropolis.cddm(n,par,max.RT,plot=TRUE)
      end_time <- Sys.time()
      Metro.time <- round(end_time-start_time, 4)
      save(X.Metro, file = "./tmp/X.Metro.RData")
      save(Metro.time, file = "./tmp/Metro.time.RData")
}else{
     # Load already existing output
     load("./tmp/X.Metro.RData")
     load("./tmp/Metro.time.RData")
     # Run the sampling algorithm to show the illlustrative plot
     z <- sample.Metropolis.cddm(n,par,max.RT,plot=TRUE)
}
```


```{r, fig.height=5}
plot.CDDM_choiceData(X.Metro, par, choice.col.RGB = rgb.Metro)
```

```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.Metro[,2], main = "Response Times", col=col.Metro(0.7))
```

```{r, fig.height=5, echo=FALSE}
plot.CDDM_margECDF(X.Metro, color=col.Metro(0.3))
```

**The execution of the Metropolis sampling algorithm took approximately `r Metro.time` seconds.**

# Algorithm 4: Inverse CDF (tabloid approximation)

```{r, eval=FALSE}
source("./code/cddm/sim_invCDF.R")
X.invCDF <- sample.invCDF.cddm(n, par, max.RT = max.RT)
```

```{r,  echo=FALSE}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun_inv|!file.exists("./tmp/X.invCDF.RData")){
      start_time <- Sys.time()
      X.invCDF <- sample.invCDF.cddm(n, par, max.RT = max.RT, plot=TRUE)
      end_time <- Sys.time()
      invCDF.time <- round(end_time-start_time,4)
      save(X.invCDF, file = "./tmp/X.invCDF.RData")
      save(invCDF.time, file = "./tmp/invCDF.time.RData")
}else{
     load("./tmp/X.invCDF.RData")    
     load("./tmp/invCDF.time.RData")
}
```

```{r, fig.height=5}
plot.CDDM_choiceData(X.invCDF, par, choice.col.RGB = rgb.invCDF)
```


```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.invCDF[,2], main = "Response Times", col = col.invCDF(0.7))
```

```{r, fig.height=5, echo=FALSE}
plot.CDDM_margECDF(X.invCDF, color=col.invCDF(0.3))
```

**The execution of the inverse-CDF algorithm took approximately `r invCDF.time` seconds.**

# Accuracy testing

### Step 1: Obtain empirical CDF (eCDF)

```{r}
# Load file containing custom eCDF function
source("./code/general_functions/eCDF.R")

RW.eCDF <- myECDF(X.RW$bivariate.data)
Reject.eCDF <- myECDF(X.Reject)
Metro.eCDF  <- myECDF(X.Metro)
invCDF.eCDF <- myECDF(X.invCDF)
```

```{r, echo=FALSE, fig.height=12}
# Plot the eCDFs obtained so far
par(pty="s", mfrow=c(2,2),mar = c(0, 0, 0, 0)) 
scatterplot3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2],
              RW.eCDF,  pch=16, cex.symbols = 0.4, color = col.RW(0.4),
              xlab = "", ylab = "", zlab = "")
mtext("Random Walk algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.Reject[,1],X.Reject[,2],Reject.eCDF, pch=16,
              cex.symbols = 0.4, color = col.Reject(0.4), 
              xlab = "", ylab = "", zlab = "")
mtext("Rejection sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.Metro[,1],X.Metro[,2],Metro.eCDF, pch=16,
              cex.symbols = 0.4, color = col.Metro(0.4), 
              xlab = "", ylab = "", zlab = "")
mtext("Metropolis sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.invCDF[,1],X.invCDF[,2],invCDF.eCDF, pch=16,
              cex.symbols = 0.4, color = col.invCDF(0.4), 
              xlab = "", ylab = "", zlab = "")
mtext("inverse-CDF tabloid sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
mtext("Empirically derived CDFs", outer=TRUE, line=-2, f=2, cex=1.2)
```

## Step 2: Approximate the theoretical CDF  (tCDF)

```{r, echo=FALSE}
# The two r-chunks below are actually just for display. This is where the CDFs are actually
# approximated from previously-saved output files, as indicated in the opening chunk.
if(forceRun|!file.exists("./tmp/Reject.tCDF.RData")){
      start_time <- Sys.time()
      RW.tCDF <- pCDDM(X.RW$bivariate.data, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      RW_tCDF.time <- round(end_time-start_time,4)
      save(RW.tCDF, file = "./tmp/RW.tCDF.RData")
      save(RW_tCDF.time, file = "./tmp/RW_tCDF.time.RData")
      
      start_time <- Sys.time()
      Reject.tCDF <- pCDDM(X.Reject, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      Rejection_tCDF.time <- round(end_time-start_time,4)
      save(Reject.tCDF, file = "./tmp/Reject.tCDF.RData")
      save(Rejection_tCDF.time, file = "./tmp/Rejection_tCDF.time.RData")
      
      start_time <- Sys.time()
      Metro.tCDF <- pCDDM(X.Metro, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      Metro_tCDF.time <- round(end_time-start_time,4)
      save(Metro.tCDF, file = "./tmp/Metro.tCDF.RData")
      save(Metro_tCDF.time, file = "./tmp/Metro_tCDF.time.RData")
      
      
      start_time <- Sys.time()
      invCDF.tCDF <- pCDDM(X.invCDF, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      invCDF_tCDF.time <- round(end_time-start_time,4)
      save(invCDF.tCDF, file = "./tmp/invCDF.tCDF.RData")
      save(invCDF_tCDF.time, file = "./tmp/invCDF_tCDF.time.RData")
}else{
     # Load already existing output
      load("./tmp/RW.tCDF.RData")
      load("./tmp/RW_tCDF.time.RData")
      load("./tmp/Reject.tCDF.RData")
      load("./tmp/Rejection_tCDF.time.RData")
      load("./tmp/Metro.tCDF.RData")
      load("./tmp/Metro_tCDF.time.RData")
      load("./tmp/invCDF.tCDF.RData")
      load("./tmp/invCDF_tCDF.time.RData")
}

times <- c(RW_tCDF.time,Rejection_tCDF.time,Metro_tCDF.time,invCDF_tCDF.time)

min_tCDF_time <- min(times)
max_tCDF_time <- max(times)
```

```{r, eval=FALSE}
RW.tCDF <- pCDDM(X.RW$bivariate.data, par$drift, par$theta, par$tzero, par$boundary)
Reject.tCDF <- pCDDM(X.Reject, par$drift, par$theta, par$tzero, par$boundary)
Metro.tCDF <- pCDDM(X.Metro, par$drift, par$theta, par$tzero, par$boundary)
invCDF.tCDF <- pCDDM(X.invCDF, par$drift, par$theta, par$tzero, par$boundary)
```

**Obtaining the approximate CDF for the data generated with each sampling algorithm took between `r min_tCDF_time` and `r max_tCDF_time`  seconds.**

```{r, echo=FALSE, fig.height=12}
# Plot the eCDFs obtained so far
par(pty="s", mfrow=c(2,2),mar = c(0, 0, 0, 0)) 
scatterplot3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2], RW.tCDF,  
              pch=3, cex.symbols = 0.3, xlab = "", ylab = "", zlab = "")
mtext("Random Walk algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.Reject[,1],X.Reject[,2],Reject.tCDF, pch=3, 
              cex.symbols = 0.3, xlab = "", ylab = "", zlab = "")
mtext("Rejection sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.Metro[,1],X.Metro[,2],Metro.tCDF, pch=3, 
              cex.symbols = 0.3, xlab = "", ylab = "", zlab = "")
mtext("Metropolis sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.invCDF[,1],X.invCDF[,2],invCDF.tCDF, pch=16,
              cex.symbols = 0.4, xlab = "", ylab = "", zlab = "")
mtext("inverse-CDF tabloid sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
mtext("Approximated CDFs", outer=TRUE, line=-2, f=2, cex=1.2)
```

## Step 3: Compare eCDFs vs approximate tCDF

```{r}
# We build a simple function to compare these CDFs
getDifferences <- function(eCDFs,tCDFs){
  difference <- tCDFs - eCDFs
  difference.sum <- apply(difference,2,sum)
  KS_statistic   <- apply(abs(difference),2,max) # Kolmogorov–Smirnov statistic
  sq.difference  <- apply(difference^2,2,sum)
  
  output <- cbind(difference.sum, KS_statistic, sq.difference)
  colnames(output) <- c("sumDiff","KS-statistic","SSDiff") 
  rownames(output) <- sub("\\..*", "", colnames(eCDFs))
  return(output)
}
```


```{r}
eCDFs <- cbind(RW.eCDF, Reject.eCDF, Metro.eCDF, invCDF.eCDF)
tCDFs <- cbind(RW.tCDF, Reject.tCDF, Metro.tCDF, invCDF.tCDF)

getDifferences(eCDFs,tCDFs)
```

```{r, echo=FALSE, fig.height=12}
# Plot the eCDFs obtained so far
par(pty="s", mfrow=c(2,2),mar = c(0, 0, 0, 0)) 
a <- scatterplot3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2],
                   RW.eCDF,  pch=16, cex.symbols = 0.8, color = col.RW(0.4),
                  xlab = "", ylab = "", zlab = "")
a$points3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2], RW.tCDF,
           pch=3, cex = 0.1)
mtext("Random Walk algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
a <- scatterplot3d(X.Reject[,1],X.Reject[,2],Reject.eCDF, pch=16, cex.symbols = 0.8, 
                   color = col.Reject(0.4), xlab = "", ylab = "", zlab = "")
a$points3d(X.Reject[,1],X.Reject[,2],Reject.tCDF, pch=3, cex = 0.1)
mtext("Rejection sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
a <- scatterplot3d(X.Metro[,1],X.Metro[,2],Metro.eCDF, pch=16, cex.symbols = 0.8, 
                   color = col.Metro(0.4), xlab = "", ylab = "", zlab = "")
a$points3d(X.Metro[,1],X.Metro[,2],Metro.tCDF, pch=3, cex = 0.1)
mtext("Metropolis sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
a <- scatterplot3d(X.invCDF[,1],X.invCDF[,2],invCDF.eCDF, pch=16, cex.symbols = 0.8, 
                   color = col.invCDF(0.4), xlab = "", ylab = "", zlab = "")
a$points3d(X.invCDF[,1],X.invCDF[,2],invCDF.tCDF, pch=3, cex = 0.1)
mtext("inverse-CDF sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
mtext("Empirical (color) vs Approximate (black) CDFs", outer=TRUE, line=-2, f=2, cex=1.2)
```

# Comparing computation times

```{r}
compareTime <- function(n.Samples, n.Datasets, par){
    empty_matrix <- matrix(NA, nrow=n.Datasets, ncol=length(n.Samples))
    times.RW  =  times.Reject = times.Metro = times.invCDF = empty_matrix
    seed <- 1
    for(m in 1:n.Datasets){ 
        set.seed(seed)
        i <- 1
        for(n in n.Samples){
            start_time <- Sys.time()
            x <- sample.RW.cddm(n,par)
            end_time <- Sys.time()
            times.RW[m,i] <- round(end_time-start_time,4)
            start_time <- Sys.time()
            max.RT <- max(x$bivariate.data[,2])
            
            sample.Reject.cddm(n,par,max.RT,plot=FALSE)
            end_time <- Sys.time()
            times.Reject[m,i] <- round(end_time-start_time, 4)
            start_time <- Sys.time()
            sample.Metropolis.cddm(n,par,max.RT=NA,plot=FALSE)
            end_time <- Sys.time()
            times.Metro[m,i] <- round(end_time-start_time,4)
            i <- i+1
            seed <- seed+1
        }
    }
return(list("times.RW" = times.RW,
            "times.Reject" = times.Reject,
            "times.Metro" = times.Metro))
}
```

```{r, echo=FALSE}
compareTime_plot <- function(n.Samples,n.Datasets,
                             times.RW, times.Reject, times.Metro){
    M <- n.Datasets; N <- n.Samples
    par(mar=c(4,4,0,1))
    x <- rep(N, each=M)
    x.RW <- (rep(N, each=M)-0.15)+(rnorm(length(N)*M,0,0.02))
    x.Reject <- (rep(N, each=M)-0.05)+(rnorm(length(N)*M,0,0.015))
    x.Metro <- (rep(N, each=M)+0.05)+(rnorm(length(N)*M,0,0.015))
    t.RW <- c(times.RW) 
    t.Reject <- c(times.Reject)
    t.Metro <- c(times.Metro)
    
    max.CompTime <- round(max(t.RW, t.Reject, t.Metro),2)
    
    RL.RW <- lm(t.RW ~x)
    B0.RW <- round(RL.RW$coefficients[1],5)
    B1.RW <- round(RL.RW$coefficients[2],5)
    RL.Reject <- lm(t.Reject ~x)
    B0.Reject <- round(RL.Reject$coefficients[1],5)
    B1.Reject <- round(RL.Reject$coefficients[2],5)
    RL.Metro <- lm(t.Metro ~x)
    B0.Metro <- round(RL.Metro$coefficients[1],5)
    B1.Metro <- round(RL.Metro$coefficients[2],5)
    plot(x.RW,t.RW, ylim=c(0,max.CompTime), xlim=c(0,max(N)+1), pch=16, cex=0.8,
         col = col.RW(0.5), ann=F, axes=F)
    points(x.Reject,t.Reject, pch=16, cex=0.8, col=col.Reject(0.5))
    points(x.Metro,t.Metro, pch=16, cex=0.8, col=col.Metro(0.5))
    axis(1, N, paste("n = ", N))
    mtext("Sample size", 1, line=2.5, f=2, cex=1.2)
    y.axis <- round(seq(0,max.CompTime,length.out=10),3)
    axis(2, y.axis, y.axis, las=2, line=-1.1)
    mtext("Y: Computation Time (in secs)", 2, line=2.5, f=2, cex=1.2)
    abline(RL.RW, col = col.RW(0.8), lwd=2)
    abline(RL.Reject, col= col.Reject(0.8), lwd=2)
    abline(RL.Metro, col= col.Metro(0.8), lwd=2)
    legend(0.5,max.CompTime, col= c(col.RW(0.8),col.Reject(0.8),col.Metro(0.8)), 
           lwd=2, bty = "n", cex=1.2,
           c(paste("RW : Y = ", B0.RW, " + ", B1.RW, "n", sep=""), 
             paste("Rejection Sampling : Y = ", B0.Reject, " + ", B1.Reject, "n", sep=""),
             paste("Metro : Y = ", B0.Metro, " + ", B1.Metro, "n", sep="")))
}
```

```{r, echo=FALSE, fig.height=6}
n.Datasets <- 10
n.Samples <- c(seq(1,20,5),50,seq(80,200,30))
test2 <- compareTime(n.Samples,n.Datasets,par)
compareTime_plot(n.Samples,n.Datasets,
                 times.RW = test2$times.RW,
                 times.Reject = test2$times.Reject,
                 times.Metro = test2$times.Metro)
```

```{r, echo=FALSE, fig.height=6}
n.Datasets <- 10
n.Samples <- 1:5
test1 <- compareTime(n.Samples,n.Datasets,par)
compareTime_plot(n.Samples,n.Datasets,
                 times.RW = test1$times.RW,
                 times.Reject = test1$times.Reject,
                 times.Metro = test1$times.Metro)
```


# Second example

Let's briefly explore the results we get when we try a second set of parameter values where we have a much larger response boundary (and a rather slower random walk process).

```{r}
# Arbitrary set of parameter values
par2 <- list("drift" = 1,   
            "theta" = pi,
            "tzero" = 0.1,
            "boundary" = 7)
n <- 5000
```


```{r echo=FALSE}
if(forceRun_RW|!file.exists("./tmp/X2.RW_2.RData")){
      X2.RW <- sample.RW.cddm(n,par2)
      save(X2.RW, file = "./tmp/X2.RW_2.RData")
   }else{     load("./tmp/X2.RW_2.RData")          }

max.RT <- max(X2.RW$bivariate.data[,2])

if(forceRun_Rej|!file.exists("./tmp/X2.Reject_2.RData")){
      X2.Reject <- sample.Reject.cddm(n,par2,max.RT,plot=FALSE)
      save(X2.Reject, file = "./tmp/X2.Reject_2.RData")
   }else{     load("./tmp/X2.Reject_2.RData")          }

if(forceRun_Met|!file.exists("./tmp/X2.Metro_2.RData")){
      X2.Metro <- sample.Metropolis.cddm(n,par2,max.RT,plot=FALSE)
      save(X2.Metro, file = "./tmp/X2.Metro_2.RData")
   }else{     load("./tmp/X2.Metro_2.RData")          }

if(forceRun_inv|!file.exists("./tmp/X2.invCDF_2.RData")){
      X2.invCDF <- sample.invCDF.cddm(n,par2,max.RT,plot=FALSE)
      save(X2.invCDF, file = "./tmp/X2.invCDF_2.RData")
   }else{     load("./tmp/X2.invCDF_2.RData")          }

RW.eCDF2 <- myECDF(X2.RW$bivariate.data)
Reject.eCDF2 <- myECDF(X2.Reject)
Metro.eCDF2 <- myECDF(X2.Metro)
invCDF.eCDF2 <- myECDF(X2.invCDF)

RW.tCDF2 <- pCDDM(X2.RW$bivariate.data, par2$drift, par2$theta, par2$tzero, par2$boundary)
Reject.tCDF2 <- pCDDM(X2.Reject, par2$drift, par2$theta, par2$tzero, par2$boundary)
Metro.tCDF2 <- pCDDM(X2.Metro, par2$drift, par2$theta, par2$tzero, par2$boundary)
invCDF.tCDF2 <- pCDDM(X2.invCDF, par2$drift, par2$theta, par2$tzero, par2$boundary)
```

```{r echo=FALSE, fig.height=5}
par(pty="m", mar = c(2, 3, 3.5, 0), mfrow=c(2,2)) 
hist(X2.RW$bivariate.data[,2], main = "", col = col.RW(0.7))
mtext("Random walk algorithm", 3, f=2, cex=0.8)
hist(X2.Reject[,2], main = "", col=col.Reject(0.7))
mtext("Rejection algorithm", 3, f=2, cex=0.8)
hist(X2.Metro[,2], main = "", col=col.Metro(0.7))
mtext("Metropolis algorithm", 3, f=2, cex=0.8)
hist(X2.invCDF[,2], main = "", col=col.invCDF(0.7))
mtext("inverse CDF algorithm", 3, f=2, cex=0.8)
mtext("Response Times sampled", outer=TRUE, line=-1.8, f=2, cex=1.9)
```

```{r, echo=FALSE, fig.height=12}
# Plot the eCDFs obtained so far
par(pty="s", mfrow=c(2,2),mar = c(0, 0, 0, 0)) 
a <- scatterplot3d(X2.RW$bivariate.data[,1], X2.RW$bivariate.data[,2],
                   RW.eCDF2,  pch=16, cex.symbols = 0.8, color = col.RW(0.4),
                  xlab = "", ylab = "", zlab = "")
a$points3d(X2.RW$bivariate.data[,1], X2.RW$bivariate.data[,2], RW.tCDF2,
           pch=3, cex = 0.1)
mtext("Random Walk algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
a <- scatterplot3d(X2.Reject[,1],X2.Reject[,2],Reject.eCDF2, pch=16, cex.symbols = 0.8, 
                   color = col.Reject(0.4), xlab = "", ylab = "", zlab = "")
a$points3d(X2.Reject[,1],X2.Reject[,2],Reject.tCDF2, pch=3, cex = 0.1)
mtext("Rejection sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
a <- scatterplot3d(X2.Metro[,1],X2.Metro[,2],Metro.eCDF2, pch=16, cex.symbols = 0.8, 
                   color = col.Metro(0.4), xlab = "", ylab = "", zlab = "")
a$points3d(X2.Metro[,1],X2.Metro[,2],Metro.tCDF2, pch=3, cex = 0.1)
mtext("Metropolis sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
a <- scatterplot3d(X2.invCDF[,1],X2.invCDF[,2],invCDF.eCDF2, pch=16, cex.symbols = 0.8, 
                   color = col.invCDF(0.4), xlab = "", ylab = "", zlab = "")
a$points3d(X2.invCDF[,1],X2.invCDF[,2],invCDF.tCDF2, pch=3, cex = 0.1)
mtext("inverse-CDF sampling algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
mtext("Empirical (color) vs Approximate (black) CDFs", outer=TRUE, line=-2, f=2, cex=1.2)
```

```{r, echo=FALSE}
eCDFs2 <- cbind(RW.eCDF2, Reject.eCDF2, Metro.eCDF2, invCDF.eCDF2) 
tCDFs2 <- cbind(RW.tCDF2, Reject.tCDF2, Metro.tCDF2, invCDF.tCDF2) 
getDifferences(eCDFs2,tCDFs2)
```


```{r, echo=FALSE, fig.height=6}
n.Datasets <- 10
n.Samples <- c(seq(1,20,5),50,seq(80,200,30))
test3 <- compareTime(n.Samples,n.Datasets,par2)
compareTime_plot(n.Samples,n.Datasets,
                 times.RW = test3$times.RW,
                 times.Reject = test3$times.Reject,
                 times.Metro = test3$times.Metro)
```

```{r, echo=FALSE, fig.height=6}
n.Datasets <- 10
n.Samples <- 1:5
test4 <- compareTime(n.Samples,n.Datasets,par2)
compareTime_plot(n.Samples,n.Datasets,
                 times.RW = test4$times.RW,
                 times.Reject = test4$times.Reject,
                 times.Metro = test4$times.Metro)
```


# References

- Smith, P. L. (2016). Diffusion theory of decision making in continuous report. *Psychological Review*, 123(4), 425.
- Smith, P. L., Garrett, P. M., & Zhou, J. (2023). Obtaining stable predicted distributions of response times and decision outcomes for the circular diffusion model. *Computational Brain & Behavior*, 6(4), 543-555.