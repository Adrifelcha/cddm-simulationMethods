---
title: "A comparison between different simulation algorithms for the CDDM in R"
author: "Adriana F. Chávez De la Peña"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
    fig_width: 12 
    fig_height: 8 
---

```{r setup, include=FALSE}
# Start Rmarkdown set up
knitr::opts_chunk$set(echo = TRUE)
library(rmdformats)
# Declare higher variables
superCalled <- TRUE # When calling external scripts, don't load nested scripts.
test <- FALSE       # When calling external scripts, don't run tests
forceRun <- FALSE   # Whether we re-run all chunks, ignoring past saved results
# Call scripts containing auxiliary custom functions
source("./code/cddm/dCDDM.R") # CDDM likelihood function - Needed for ALL algorithms
source("./code/cddm/sim_randomWalk.R") # Needed for Fig.1 and Algorithm 1
source("./code/cddm/sim_MCMC.R") # Needed for Algorithm 2
source("./code/cddm/plottingFunctions.R") # Needed to plot choices on a circle
source("./code/cddm/pCDDM.R") # Needed for approximating the CDF under the CDDM
# Short custom functions for plotting
rgb.RW <- c(255/255,128/255,0)
rgb.MCMC <- c(0.4,.9,.3)
col.RW <- function(opacity){rgb(rgb.RW[1],rgb.RW[2],rgb.RW[3],opacity)}
col.MCMC <- function(opacity){rgb(rgb.MCMC[1],rgb.MCMC[2],rgb.MCMC[3],opacity)}
```

<!-- # Introduction -->

<!-- The present document is included as support material for the project presented in: -->

<!-- > Chávez De la Peña, A. F. & Vandekerckhove, J. (n.a.). Simulating circular decisions using the circular drift-diffusion model: A comparison across different simulation methods. *work in progress*. -->

<!-- The main goal of the project was to develop different sampling algorithms that could be used to generate data under the CDDM, and compare their performance in terms of computation time and accuracy.  -->

<!-- This document is a short report intended to provide an executive  -->



# The Circular Drift Diffusion Model

The circular drift-diffusion model (CDDM) is a stochastic sequential sampling model that describes choices and response times observed in tasks with a circular decision space (Smith, 2016). Like many other accumulator models, the CDDM assumes that participants accumulate information in favor of a given response option over time, until a response criteria is met. This is characterized as a random walk that starts at the origin of a circle representing the decision space, and that moves towards its circumference. Once the circumference is reached, the radian corresponding to the point of intersection and the amount of steps it took to get there are indicative of the choice and response times observed.

The CDDM considers four parameters, most of which are illustrated in Fig 1. The parameter not shown is the nondecision time parameter $\tau$. The remaining parameters are the boundary radius parameter ($\eta$) that serves as a response criterion, and a doublet of parameters describing the overall speed and direction of the information accumulation process. These last two parameters can be expressed in cartesian coordinates (i.e., the mean displacement observed on the X and Y coordinates per unit of time $\{\mu_x, \mu_y\}$) or polar coordinates (i.e., the average speed and expected direction $\{\delta,\theta\}$).

```{r, echo=FALSE, message=FALSE, fig.align='center', fig.cap="Fig 1. Graphical illustration of the CDDM"}
source("./code/cddm/illustrateModel_Fig1.R")
```

```{r set-up, echo=FALSE}
# Arbitrary set of parameter values
par <- list("drift" = 1, 
            "theta" = pi,
            "tzero" = 0.1,
            "boundary" = 7)
n <- 5000 # No. samples
```


In this document, we present a comparison between different sampling algorithms that generate data under the CDDM. We will describe how each of these algorithms work and highlight how different they are in terms of the computation time they require and their accuracy. For starters, we will generate `n = ` `r n` bivariate observations using the arbitrary set of parameter values shown below:

```{r set-up, eval=FALSE}
```

# Algorithm 1: Random walk emulator

Each pair of observations is obtained by emulating the random walk process described by the CDDM. We emulate the information accumulation process by iteratively sampling random movements on the X and Y direction using $\mu_x$ and $\mu_y$, until the 

```{r, eval=FALSE}
source("./code/cddm/sim_randomWalk.R")
X.RW <- sample.RW.cddm(n,par)
```

```{r,  echo=FALSE}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun|!file.exists("./tmp/X.RW.RData")){
      start_time <- Sys.time()
      X.RW <- sample.RW.cddm(n,par)
      end_time <- Sys.time()
      RW.time <- round(end_time-start_time,4)
      save(X.RW, file = "./tmp/X.RW.RData")
      save(RW.time, file = "./tmp/RW.time.RData")
}else{
     load("./tmp/X.RW.RData")    
     load("./tmp/RW.time.RData")
}
```

```{r, fig.height=5}
plot.CDDM(X.RW, par, choice.col.RGB = rgb.RW)
```


```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.RW$bivariate.data[,2], main = "Response Times", col = col.RW(0.7))
```

*The execution of this first algorithm took approximately `r RW.time` seconds.*

# Algorithm 2: Rejection sampling

```{r}
max.RT <- max(X.RW$bivariate.data[,2])
```

```{r, eval=FALSE}
source("./code/cddm/sim_MCMC.R")
X.MCMC <- sample.MCMC.cddm(n,par,max.RT,plot=TRUE)
```

```{r,  echo=FALSE, fig.cap="Fig.2 Visual representation of the MCMC-MH rejection algorithm. The blue lines represent the joint density function of response times and choices prescribed by the CDDM. The dots represent the pairs of candidate value generated from the bivariate space of possible RTs and choices, plotted at the height of the random uniform(0, maxDensity) value used as rejection criterion. If the rejection criterion was lower than the density function (i.e., dot falls below density curve), the sample is accepted; if the rejection value surpasses the density (i.e., dot is drawn above), the candidate is rejected. The process of generating, testing and keeping candidates is repeated until the desired sample size is achieved."}
# The r-chunk above is actually just for display. This is where the samples are actually
# generated or loaded from previously-saved output files, as indicated in the opening chunk.
if(forceRun|!file.exists("./tmp/X.MCMC.RData")){
      start_time <- Sys.time()
      X.MCMC <- sample.MCMC.cddm(n,par,max.RT,plot=TRUE)
      end_time <- Sys.time()
      MC.time <- round(end_time-start_time, 4)
      save(X.MCMC, file = "./tmp/X.MCMC.RData")
      save(MC.time, file = "./tmp/MC.time.RData")
}else{
     # Load already existing output
     load("./tmp/X.MCMC.RData")
     load("./tmp/MC.time.RData")
     # Run the sampling algorithm to show the illlustrative plot
     z <- sample.MCMC.cddm(n,par,max.RT,plot=TRUE)
}
```

*The execution of this second algorithm took approximately `r MC.time` seconds.*

```{r, fig.height=5}
plot.CDDM(X.MCMC, par, choice.col.RGB = rgb.MCMC)
```

```{r, fig.height=5}
par(pty="m", mar = c(3, 3, 3, 0)) 
hist(X.MCMC[,2], main = "Response Times", col=col.MCMC(0.7))
```

# Algorithm 3: Metropolis algorithm

The following MCMC rejection-sampler algorithm (Metropolis-Hasting) uses the density function to generate random observations under the CDDM. Please read the comments I’ve left through the code to get a better idea on how this algorithm works. In order to work, this algorithm only needs a list par that specifies the values to use for each of the four parameters of the model (in either of its parameterizations, using polar or cartesian coordinates), and an arbitrary value max.RT that indicates the maximum possible R.T we’d expect to observe under a realistic scenario.

# Algorithm 4: Inverse CDF



# Accuracy testing

### Step 1: Obtain empirical CDF (eCDF)

```{r}
# Load file containing custom eCDF function
source("./code/general_functions/eCDF.R")

MCMC.eCDF <- myECDF(X.MCMC)
RW.eCDF <- myECDF(X.RW$bivariate.data)
```

```{r, echo=FALSE}
# Plot the eCDFs obtained so far
par(pty="s")          
par(mfrow=c(1,2),mar = c(0, 0, 0, 0)) 
scatterplot3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2],
              RW.eCDF,  pch=16, cex.symbols = 0.5, color = col.RW(0.4),
              xlab = "", ylab = "", zlab = "")
mtext("Random Walk algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.MCMC[,1],X.MCMC[,2],MCMC.eCDF, pch=16,
              cex.symbols = 0.5, color = col.MCMC(0.4), 
              xlab = "", ylab = "", zlab = "")
mtext("MCMC-MH algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
mtext("Empirically derived CDFs", outer=TRUE, line=-2, f=2, cex=1.2)
```

## Step 2: Approximate the theoretical CDF  (tCDF)

```{r, echo=FALSE}
# The two r-chunks below are actually just for display. This is where the CDFs are actually
# approximated from previously-saved output files, as indicated in the opening chunk.
if(forceRun|!file.exists("./tmp/MCMC.tCDF.RData")){
      start_time <- Sys.time()
      MCMC.tCDF <- pCDDM(X.MCMC, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      MC_tCDF.time <- round(end_time-start_time,4)
      save(MCMC.tCDF, file = "./tmp/MCMC.tCDF.RData")
      save(MC_tCDF.time, file = "./tmp/MC_tCDF.time.RData")
      start_time <- Sys.time()
      RW.tCDF <- pCDDM(X.RW$bivariate.data, par$drift, par$theta, par$tzero, par$boundary)
      end_time <- Sys.time()
      RW_tCDF.time <- round(end_time-start_time,4)
      save(RW.tCDF, file = "./tmp/RW.tCDF.RData")
      save(RW_tCDF.time, file = "./tmp/RW_tCDF.time.RData")
}else{
     # Load already existing output
      load("./tmp/MCMC.tCDF.RData")
      load("./tmp/MC_tCDF.time.RData")
      load("./tmp/RW.tCDF.RData")
      load("./tmp/RW_tCDF.time.RData")
}
```

```{r, eval=FALSE}
source("./code/cddm/pCDDM.R")

# Approximate the theoretical CDF for the MCMC data
start_time <- Sys.time()
MCMC.tCDF <- pCDDM(X.MCMC, par$drift, par$theta, par$tzero, par$boundary)
end_time <- Sys.time()
MC_tCDF.time <- end_time-start_time
MC_tCDF.time <- round(MC_tCDF.time,4)
```

*Obtaining the approximate CDF for the MCMC data with a trapezoid algorithm took `r MC_tCDF.time` **minutes**.*

```{r, eval=FALSE}
# Approximate the theoretical CDF for the Random Walk data
start_time <- Sys.time()
RW.tCDF <- pCDDM(X.RW$bivariate.data, par$drift, par$theta, par$tzero, par$boundary)
end_time <- Sys.time()
RW_tCDF.time <- end_time-start_time
RW_tCDF.time <- round(RW_tCDF.time,4)
```

*Obtaining the approximate CDF for the Random-Walk data with a trapezoid algorithm took `r RW_tCDF.time` **minutes**.*

```{r, echo=FALSE}
# Plot the eCDFs obtained so far
par(pty="s")          
par(mfrow=c(1,2),mar = c(0, 0, 0, 0)) 
scatterplot3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2],
              RW.tCDF,  pch=3, cex.symbols = 0.5, color = col.RW(0.4),
              xlab = "", ylab = "", zlab = "")
mtext("Random Walk algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
scatterplot3d(X.MCMC[,1],X.MCMC[,2],MCMC.tCDF, pch=3,
              cex.symbols = 0.5, color = col.MCMC(0.4), 
              xlab = "", ylab = "", zlab = "")
mtext("MCMC-MH algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
mtext("Approximated CDFs", outer=TRUE, line=-2, f=2, cex=1.2)
```

## Step 3: Compare eCDFs vs approximate tCDF

```{r}
# We build a simple function to compare these CDFs
getDifferences <- function(eCDF,tCDF){
  difference <- tCDF - eCDF
  difference.sum <- sum(difference)
  KS_statistic <- max(abs(difference)) # Kolmogorov–Smirnov statistic
  sq.difference <- sum((difference)^2)
  
  output <- round(cbind(difference.sum,KS_statistic,sq.difference),4)
  colnames(output) <- c("sumDiff","KS-statistic","SSDiff") 
  return(output)
}
```


```{r}
getDifferences(MCMC.eCDF,MCMC.tCDF)
getDifferences(RW.eCDF,RW.tCDF)
```

```{r, echo=FALSE}
# Plot the eCDFs obtained so far
par(pty="s")          
par(mfrow=c(1,2),mar = c(0, 0, 0, 0)) 
a <- scatterplot3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2],
                   RW.eCDF,  pch=16, cex.symbols = 0.8, color = col.RW(0.4),
                  xlab = "", ylab = "", zlab = "")
a$points3d(X.RW$bivariate.data[,1], X.RW$bivariate.data[,2], RW.tCDF,
           pch=3, cex = 0.1)
mtext("Random Walk algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
a <- scatterplot3d(X.MCMC[,1],X.MCMC[,2],MCMC.eCDF, pch=16, cex.symbols = 0.8, 
                   color = col.MCMC(0.4), xlab = "", ylab = "", zlab = "")
a$points3d(X.MCMC[,1],X.MCMC[,2],MCMC.tCDF, pch=3, cex = 0.1)
mtext("MCMC-MH algorithm", f=2)
mtext("Choices", side=1, line=0.5)
mtext("RTs", side=4, line=-1, adj=0)
mtext("Empirical (color) vs Approximate (black) CDFs", outer=TRUE, line=-2, f=2, cex=1.2)
```

# Comparing computation times

```{r}
N <- 1:5
M <- 20

times.RW   <- matrix(NA, nrow=M, ncol=max(N))
times.MCMC <- matrix(NA, nrow=M, ncol=max(N))
for(m in 1:M){
    for(n in N){
      start_time <- Sys.time()
      sample.RW.cddm(n,par)
      end_time <- Sys.time()
      times.RW[m,n] <- round(end_time-start_time,4)
      
      start_time <- Sys.time()
      sample.MCMC.cddm(n,par,max.RT,plot=FALSE)
      end_time <- Sys.time()
      times.MCMC[m,n] <- round(end_time-start_time, 4)
    }
}
```

```{r, echo=FALSE, fig.height=6}
#par(mar = c(1, 1, 1, 1))#, oma = c(0, 0, 0, 0))
par(mar=c(4,4,0,1))
x <- rep(N, each=M)
x.RW <- (rep(N, each=M)+0.15)+(rnorm(max(N)*M,0,0.02))
x.MCMC <- (rep(N, each=M)-0.15)+(rnorm(max(N)*M,0,0.015))
t.RW <- c(times.RW)
t.MCMC <- c(times.MCMC)

max.CompTime <- round(max(times.RW),2)

RL.RW <- lm(t.RW ~x)
B0.RW <- round(RL.RW$coefficients[1],5)
B1.RW <- round(RL.RW$coefficients[2],5)
RL.MCMC <- lm(t.MCMC ~x)
B0.MCMC <- round(RL.MCMC$coefficients[1],5)
B1.MCMC <- round(RL.MCMC$coefficients[2],5)
plot(x.RW,t.RW, ylim=c(0,max.CompTime), xlim=c(0,max(N)+1), pch=16, cex=0.8,
     col = col.RW(0.5), ann=F, axes=F)
points(x.MCMC,t.MCMC, pch=16, cex=0.8, col=col.MCMC(0.5))
axis(1, N, paste("n = ", N))
mtext("Sample size", 1, line=2.5, f=2, cex=1.2)
axis(2, seq(0,max.CompTime,0.005), seq(0,max.CompTime,0.005), las=2, line=-1.1)
mtext("Y: Computation Time (in secs)", 2, line=2.5, f=2, cex=1.2)
abline(RL.RW, col = col.RW(0.8), lwd=2)
abline(RL.MCMC, col= col.MCMC(0.8), lwd=2)
legend(0.5,max.CompTime, col= c(col.RW(0.8),col.MCMC(0.8)), lwd=2, bty = "n", 
       c(paste("RW : Y = ", B0.RW, " + ", B1.RW, "n", sep=""), 
         paste("MCMC : Y = ", B0.MCMC, " + ", B1.MCMC, "n", sep="")), cex=1.2)
```




# References

- Smith, P. L. (2016). Diffusion theory of decision making in continuous report. *Psychological Review*, 123(4), 425.
- Smith, P. L., Garrett, P. M., & Zhou, J. (2023). Obtaining stable predicted distributions of response times and decision outcomes for the circular diffusion model. *Computational Brain & Behavior*, 6(4), 543-555.